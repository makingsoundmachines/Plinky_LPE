#include "strings.h"
#include "data/tables.h"
#include "hardware/adc_dac.h"
#include "hardware/midi.h"
#include "hardware/midi_defs.h"
#include "hardware/touchstrips.h"
#include "pitch_tools.h"
#include "sequencer.h"
#include "synth/arp.h"
#include "synth/sequencer.h"
#include "synth/time.h"
#include "ui/pad_actions.h"
#include "ui/shift_states.h"
#include "ui/ui.h"

extern Preset rampreset;
// -- needs cleaning up

// current frame in string_touch
static u8 strings_write_frame;
static u8 strings_read_frame;

// a string_touch is a virtual touch, it can be generated by a physical touch, latching, arp and sequencer
//
// pointers to this array should always be marked with an s-prefix (s_touch) to differentiate them from pointers named
// "touch", which refer to a physical touch read from the touchstrips
static Touch string_touch[NUM_STRINGS][NUM_TOUCH_FRAMES];

// the same array as above, but sorted by pitch
static Touch string_touch_sorted[NUM_STRINGS][NUM_TOUCH_FRAMES];

// bitmasks that keep track of touches on the read_frame, implements hysteresis
u8 string_touched = 0;
static u8 string_touched_1back = 0;
u8 string_touch_start = 0;

// bitmasks of touches during the write_frame, used for arp and latch checking
static u8 write_string_touched;
u8 write_string_touched_copy = 0; // direct copy of the above
u8 write_string_touched_1back = 0;
static u8 strings_phys_touched = 0;

// midi
u8 midi_note[NUM_STRINGS];
static u8 midi_velocity[NUM_STRINGS];
static u8 midi_poly_pressure[NUM_STRINGS];
static u16 midi_position[NUM_STRINGS]; // for pulsing leds at note position
u8 midi_channel[NUM_STRINGS] = {255, 255, 255, 255, 255, 255, 255, 255};
u8 midi_pressure_override = 0; // true if midi note is pressed
u8 midi_pitch_override = 0;    // true if midi note is sounded out, includes release phase
u8 midi_suppress = 0;          // true if midi is suppressed by touch / latch / seq

// latching

typedef struct TouchMemCompressed {
	u8 pos;
	u8 pres;
} TouchMemCompressed;

static TouchMemCompressed latch_touch[8];

void clear_latch(void) {
	memset(latch_touch, 0, sizeof(latch_touch));
}

// -- latching

// this only exists for midi output - remove after midi cleanup
Touch* get_string_touch_prev(u8 string_id, u8 frames_back) {
	return &string_touch[string_id][(strings_write_frame - frames_back) & 7];
}

Touch* get_string_touch(u8 string_id) {
	return &string_touch[string_id][strings_read_frame];
}

Touch* sorted_string_touch_ptr(u8 string_id) {
	return &string_touch_sorted[string_id][0];
}

// this combines inputs from touchstrips, latch, arp & sequencer, and saves the resulting Touch in
// string_touch[string_id]
static void generate_string_touch(u8 string_id) {
	static bool suppress_latch = false;
	// helpers
	u8 mask = 1 << string_id;
	bool is_read = touch_read_this_frame(string_id);
	s16 pres_2back =
	    get_touch_prev(string_id, is_read ? 2 : 3)->pres; // this is because we only update every other frame?
	bool pres_increasing = false;
	// fundamental
	Touch* touch = get_touch_prev(string_id, is_read ? 0 : 1); // the touch we're processing
	Touch* s_touch =
	    &string_touch[string_id][strings_write_frame]; // the string-touch that results from that processing
	s16 pressure = TOUCH_MIN_PRES; // we save the resulting pressure in here until we write it to s_touch
	s16 position = TOUCH_MIN_POS;  // we save the resulting position in here until we write it to s_touch

	// === TOUCH INPUT === //

	if (strip_available_for_synth(string_id) || ui_mode == UI_SAMPLE_EDIT) {
		// read touch values
		pressure = touch->pres;
		position = touch->pos;
		pres_increasing = pressure > pres_2back;
		// log touch
		if (pressure > 0)
			strings_phys_touched |= mask;
		else
			strings_phys_touched &= ~mask;

		// === LATCH WRITE === //

		// finger touching and pressure increasing
		if ((rampreset.flags & FLAGS_LATCH) && pressure > 0 && pres_increasing) {
			// is this a new touch after no fingers where touching?
			if (pres_2back <= 0 && strings_phys_touched == mask) {
				// start a new latch, clear all previous latch values
				for (u8 i = 0; i < NUM_STRINGS; i++) {
					latch_touch[i].pres = 0;
					latch_touch[i].pos = 0;
				}
				// in step record mode, trying to start a new latch temporarily turns off latching
				// trying to start a new latch outside of step record mode turns it on again
				suppress_latch = seq_state() == SEQ_STEP_RECORDING;
			}
			// save latch values
			if (!suppress_latch) {
				latch_touch[string_id].pres = pres_compress(pressure);
				latch_touch[string_id].pos = pos_compress(position);
			}
			// RJ: I could not work out a way to work with average values that wasn't
			// sluggish or gave undesired intermediate values - slides and in-between notes
			// Current solution is just saving one value and randomizing when reading it out
			// Result feels great, but good to reconsider when the exact contents of
			// touchstrip and string_touch are more clear

			// Averaging code for reference:
			//
			// u8 max_pos = 0, min_pos = 255, maxpressure = 0;
			// Touch* f = string_touch[string_id];
			// for (int j = 0; j < 8; ++j, ++f) {
			// 	u8 p = clampi((f->pos + 4) / 8, 0, 255);
			// 	min_pos = mini(p, min_pos);
			// 	max_pos = maxi(p, max_pos);
			// 	u8 pr = clampi(f->pres / 12, 0, 255);
			// 	maxpressure = maxi(maxpressure, pr);
			// }
			// latch[string_id].pres = maxpressure;
			// latch[string_id].min_pos = min_pos;
			// latch[string_id].max_pos = max_pos;
		}
	}

	// === LATCH RECALL === //

	// latch pressure larger than touch pressure
	if ((rampreset.flags & FLAGS_LATCH) && latch_touch[string_id].pres > 0
	    && latch_touch[string_id].pres * 24 > pressure) {
		// recall latch values
		pressure = pres_decompress(latch_touch[string_id].pres);
		position = pos_decompress(latch_touch[string_id].pos);

		// signal sequencer it's okay to record this
		pres_increasing = true;

		// Averaging code for reference:
		//
		// int min_pos = latch[string_id].min_pos * 8 + 2;
		// int max_pos = latch[string_id].max_pos * 8 + 6;
		// int avgpos = (min_pos + max_pos) / 2;
		// int range = (max_pos - min_pos) / 4;
		// pressure = latchpres ? rand_range(latchpres - 12, latchpres) : -1024;
		// position = rand_range(avgpos-range,avgpos+range);
	}

	// record touch to sequencer
	seq_try_rec_touch(string_id, pressure, position, pres_increasing);

	// retrieve touch from sequencer
	if (pressure <= 0)
		seq_try_get_touch(string_id, s_touch, &pressure, &position);

	// === MIDI INPUT === //

	// midi gets suppressed if touch, latch or sequencer generate pressure
	if (pressure > 0)
		midi_suppress |= mask;
	else
		midi_suppress &= ~mask;
	// a midi note is playing this string
	if ((midi_pressure_override & mask) && !(midi_suppress & mask)) {
		// take pressure and position from midi data
		pressure = 1
		           + (midi_velocity[string_id]
		              + maxi(midi_poly_pressure[string_id], midi_chan_pressure[midi_channel[string_id]]))
		                 * 16;
		// for midi, position only defines where the leds light up on the string
		position = midi_position[string_id];
	}

	// === CV GATE === //

	// scale pressure with cv gate input
	pressure = pressure * adc_get_smooth(ADC_S_GATE);

	// === FINISHING UP === //

	// new finger touch => fill (non-pressed) history with slightly randomized variant of current position
	static s16 pres_1back[NUM_STRINGS];
	if (pres_1back[string_id] <= 0 && s_touch->pres > 0) {
		Touch* st = string_touch[string_id];
		for (u8 string_id = 0; string_id < NUM_STRINGS; ++string_id, st++)
			if (string_id != strings_write_frame && st->pres <= 0)
				st->pos = position ^ (st->pos & 3);
	}
	pres_1back[string_id] = s_touch->pres;

	// save resulting touch to main array
	s_touch->pres = pressure;
	s_touch->pos = position;
	if (s_touch->pres > 0)
		write_string_touched |= mask;
	else
		write_string_touched &= ~mask;

	// sort string's frames by position
	sort8((int*)string_touch_sorted[string_id], (int*)string_touch[string_id]);
}

// manage generating the string_touch array
void generate_string_touches(void) {
	static bool do_second_half = false;
	static u8 strings_phys_touch_1back = 0;

	// update half of the strings (0 - 3 / 4 - 7)
	for (u8 string_id = 0; string_id < NUM_STRINGS / 2; ++string_id)
		generate_string_touch(string_id + do_second_half * NUM_STRINGS / 2);
	// end of a full update of all strings
	if (do_second_half) {
		// lift the last finger in step record mode: auto-step forward
		if (seq_state() == SEQ_STEP_RECORDING && !strings_phys_touched && strings_phys_touch_1back)
			seq_inc_step();
		strings_phys_touch_1back = strings_phys_touched;

		// new (virtual) touch: restart arp
		if (arp_order != ARP_NONE && write_string_touched_copy && !write_string_touched_1back) {
			arp_reset();
			// if the sequencer is not playing, resync the clock so the arp gets a trigger immediately
			if (!seq_playing())
				clock_resync();
		}

		// processing the strings happens at a significantly higher framerate than reading out the touchstrips
		// u8 touch_frame tracks which frame in the touches array is currently being written to
		// u8 strings_write_frame tracks which frame in the string_touch array we are writing to
		// we never want any half-filled frames in the string_touch array, so we only update strings_write_frame after
		// processing a full frame of strings
		//
		// in practice, all internal functionality (arp, sequencer, mod sources, etc) get processed at the higher
		// framerate - whenever touchstrips.h has read out a full frame of touches, strings_write_frame increments to
		// make use of the new touch-data
		if (strings_write_frame != touch_frame) {
			// we read from the frame that was written just before
			strings_read_frame = strings_write_frame;
			// we write to the frame that is currently being processed by the touchstrips
			strings_write_frame = touch_frame;
		}
	}
	// toggle which half we process
	do_second_half = !do_second_half;

	string_touched_1back = string_touched;
	string_touched = 0;
	for (u8 string_id = 0; string_id < NUM_STRINGS; ++string_id) {
		Touch* s_touch = get_string_touch(string_id);
		s8 thresh = (string_touched_1back & (1 << string_id)) ? -50 : 1; // hysteresis
		if (s_touch->pres > thresh) {
			string_touched |= 1 << string_id;
		}
	}
	string_touch_start = (string_touched & ~string_touched_1back);

	write_string_touched_1back = write_string_touched_copy;
	write_string_touched_copy = write_string_touched;
}

// == MIDI == //

static u8 find_midi_note_string(u8 chan, u8 note) {
	for (int string_id = 0; string_id < 8; ++string_id)
		if ((midi_pitch_override & (1 << string_id)) && midi_note[string_id] == note && midi_channel[string_id] == chan)
			return string_id;
	return 255;
}

static u8 find_string_for_midi_pitch(int midi_pitch) {
	// pitch falls below center of bottom string
	if (midi_pitch < string_center_pitch(0))
		return 0;
	// pitch falls above center of top string
	if (midi_pitch >= string_center_pitch(7))
		return 7;
	// find the string with the closest center pitch
	u8 desired_string = 0;
	s32 min_dist = 2147483647; // int max
	for (u8 i = 0; i < 8; i++) {
		u32 pitch_dist = abs(string_center_pitch(i) - midi_pitch);
		if (pitch_dist < min_dist) {
			min_dist = pitch_dist;
			desired_string = i;
		}
	}
	return desired_string;
}

// return the position of the highest pad the midi pitch is higher than - or equal to
static u16 find_string_position_for_midi_pitch(u8 string_id, int midi_pitch) {
	// top pad has pad_y 0
	// pad spacing is 256 per pad, position = pad_y << 8
	for (u8 pad = 7; pad > 0; pad--) {
		if (midi_pitch >= string_pitch_at_pad(string_id, pad)) {
			return (7 - pad) << 8;
		}
	}
	// if the pitch was lower than the pitch of pad 1, we return the bottom pad
	return 7 << 8;
}

static u8 find_free_midi_string(u8 midi_note_number, u16* midi_note_position, u8 chan) {
	Touch* s_touch = get_string_touch(0);
	s32 midi_pitch = 12 *
	                     // pitch from octave parameter
	                     ((param_eval_finger(P_OCT, 0, s_touch) << 9)
	                      // pitch from pitch parameter
	                      + (param_eval_finger(P_PITCH, 0, s_touch) >> 7))
	                 // pitch from midi note
	                 + midi_note_to_pitch_offset(midi_note_number, chan);

	// find the best string for this midi note
	u8 desired_string = find_string_for_midi_pitch(midi_pitch);

	// try to find:
	// 1. the non-pressed, non-sounding string closest to our desired string
	// 2. the non-pressed string that is the quietest
	u8 string_option[8];
	u8 num_string_options = 0;
	u8 min_string_dist = 255;
	float min_vol = __FLT_MAX__;
	u8 min_string_id = 255;

	// collect non-pressed, non-sounding strings
	for (u8 string_id = 0; string_id < 8; string_id++) {
		if (!(midi_pressure_override & (1 << string_id)) && !(write_string_touched & (1 << string_id))
		    && voices[string_id].env1_lvl < 0.001f) {
			string_option[num_string_options] = string_id;
			num_string_options++;
		}
	}
	// find closest
	for (u8 option_id = 0; option_id < num_string_options; option_id++) {
		if (abs(string_option[option_id] - desired_string) < min_string_dist) {
			min_string_dist = abs(string_option[option_id] - desired_string);
			min_string_id = string_option[option_id];
		}
	}
	// return closest, if found
	if (min_string_dist != 255) {
		// collect the position on the string before returning
		*midi_note_position = find_string_position_for_midi_pitch(min_string_id, midi_pitch);
		return min_string_id;
	}
	// collect non-pressed strings
	num_string_options = 0;
	for (u8 string_id = 0; string_id < 8; string_id++) {
		if (!(midi_pressure_override & (1 << string_id)) && !(write_string_touched & (1 << string_id))) {
			string_option[num_string_options] = string_id;
			num_string_options++;
		}
	}
	// find quietest
	for (u8 option_id = 0; option_id < num_string_options; option_id++) {
		if (voices[string_option[option_id]].env1_lvl < min_vol) {
			min_vol = voices[string_option[option_id]].env1_lvl;
			min_string_id = string_option[option_id];
		}
	}
	// collect the position on the string before returning
	if (min_string_id != 255) {
		*midi_note_position = find_string_position_for_midi_pitch(min_string_id, midi_pitch);
	}
	// return quietest - this returns 255 if nothing was found
	return min_string_id;
}

void strings_rcv_midi(u8 status, u8 d1, u8 d2) {
	u8 chan = status & 0x0F; // save the channel
	u8 type = status & 0xF0; // take the channel out

	switch (type) {
	case MIDI_NOTE_OFF: {
		// find string with existing midi note
		u8 string_id = find_midi_note_string(chan, d1);
		if (string_id < NUM_STRINGS) {
			// deactivate midi for string
			midi_pressure_override &= ~(1 << string_id);
		}
	} break;
	case MIDI_NOTE_ON: {
		u16 note_position;
		// find string with existing midi note
		u8 string_id = find_midi_note_string(chan, d1);
		// none found - find empty string
		if (string_id == 255) {
			string_id = find_free_midi_string(d1, &note_position, chan);
			if (string_id < NUM_STRINGS)
				midi_position[string_id] = note_position;
		}
		if (string_id < NUM_STRINGS) {
			// save in string
			midi_note[string_id] = d1;
			midi_channel[string_id] = chan;
			midi_velocity[string_id] = d2;
			midi_poly_pressure[string_id] = 0;
			// activate midi for string
			midi_pressure_override |= 1 << string_id;
			midi_pitch_override |= 1 << string_id;
		}
	} break;
	case MIDI_POLY_KEY_PRESSURE: {
		u8 string_id = find_midi_note_string(chan, d1);
		if (string_id < NUM_STRINGS) {
			midi_poly_pressure[string_id] = d2;
		}
	} break;
	}
}

void strings_clear_midi(void) {
	midi_pressure_override = 0;
	midi_pitch_override = 0;
	memset(midi_note, 0, sizeof(midi_note));
	memset(midi_velocity, 0, sizeof(midi_velocity));
	memset(midi_poly_pressure, 0, sizeof(midi_poly_pressure));
	memset(midi_channel, 255, sizeof(midi_channel));
}
